---
tip: translate by openai@2023-06-02 15:32:58
title: Navigate To Pose and Pause Near Goal-Obstacle
---

::: note
::: title
Note
:::

As a prerequisite, we encourage the users to go through the [Behavior Tree documentation](https://behaviortree.github.io/BehaviorTree.CPP/), which explains about different behaviors nodes used in these trees such as `ReactiveSequence`, `SequenceStar` and `RetryUntilSucessfull`.

> 作为先决条件，我们鼓励用户阅读[行为树文档]，其中解释了在这些树中使用的不同行为节点，例如`ReactiveSequence`、`SequenceStar`和`RetryUntilSucessfull`。

:::

This behavior tree is a soft extension to the `behavior_tree_nav_to_pose`. Apart from the functionalities of `behavior_tree_nav_to_pose`, this behavior tree allows the robot to efficiently handle an obstacle (e.g. forklift, person, or other temporary obstacles) close to the goal by pausing the robot\'s navigation and wait for a user-specified time to check if the obstacle has cleared. If the obstacle has moved during the waiting time, the robot will continue to the goal taking the shorter path. If the obstacle has not moved during the waiting time or the waiting time expires, then the robot will use the longer path around to reach the final goal location. Ultimately, for a given task, this behavior tree aids in solving the problem of long cycle time, which is caused because of the long path generated due to the temporary obstacles present close to the goal location.

> 这个行为树是对`behavior_tree_nav_to_pose`的软扩展。除了`behavior_tree_nav_to_pose`的功能外，此行为树还**允许机器人有效地处理目标附近的障碍**（例如叉车、人或其他临时障碍），通过**暂停机器人的导航并等待用户指定的时间来检查障碍是否已清除**。如果障碍在等待时间内移动，机器人将继续沿着较短路径前往目标。如果障碍在等待时间内未移动或等待时间到期，则机器人将使用较长路径绕行以达到最终目标位置。最终，对于给定的任务，此行为树有助于解决由于目标位置附近存在临时障碍而产生的长周期时间问题。

> [!NOTE]
> 这个不仅仅是可以做故障模式的切换，还可以做不同模式的切换。很好很好！

The behavior tree is depicted in the image below. From the image, it can be noted that there is an additional branch in the Navigation Subtree known as `MonitorAndFollowPath`. This branch is created with the intention for the users to perform any kind of monitoring behavior that their robot should exhibit. In this particular BT, the monitoring branch is exclusively utilized by `PathLongerOnApproach` BT node for checking if the global planner has decided to plan a significantly longer path for the robot on approaching the user-specified goal proximity. If there is no significantly longer path, the monitor node goes into the `FollowPath` recovery node, which then generates the necessary control commands.

> 图片下方描绘了行为树。从图片中可以看出，**导航子树中有一个额外的分支**，称为`MonitorAndFollowPath`。此分支的创建意图是让用户为机器人**执行任何类型的监测行为**。在这个特定的行为树中，监控分支仅由`PathLongerOnApproach` BT 节点使用，用于检查全局规划师是否决定在机器人接近用户指定的目标接近度时计划显着更长的路径。**如果没有显着更长的路径，监视节点进入`FollowPath`恢复节点**，然后生成必要的控制命令。

![image](../images/walkthrough/patience_and_recovery.png)

Once there is a significantly longer path, the child node for the `PathLongerOnApproach` node ticks. The child node is a `RetryUntilSuccesfull` decorator node, which inturns have a `SequenceStar` node as its child. Firstly, the `SequenceStar` node cancels the controller server by ticking the `CancelControl` node. The cancellation of the controller server halts the further navigation of the robot. Next, the `SequenceStar` node ticks the `Wait` node, which enables the robot to wait for the given user-specified time. Here we need to note that, the `MonitorAndFollowPath` is a `ReactiveSequence` node, therefore the `PathLongerOnApproach` node needs to return SUCCESS, before the `FollowPath` node can be ticked once again.

> 一旦有一条显著更长的路径，`PathLongerOnApproach`节点的子节点就会打钩。子节点是一个`RetryUntilSuccesfull`装饰器节点，它又有一个`SequenceStar`节点作为它的子节点。首先，`SequenceStar`节点会通过打钩`CancelControl`节点来取消控制服务器。控制服务器的取消会中断机器人的进一步导航。接下来，`SequenceStar`节点会打钩`Wait`节点，这使机器人能够等待给定的用户指定的时间。这里我们需要注意的是，`MonitorAndFollowPath`是一个`ReactiveSequence`节点，因此`PathLongerOnApproach`节点需要返回 `SUCCESS`，然后才能再次打钩`FollowPath`节点。

In the below GIF, it can be seen that the robot is approaching the goal location, but it found an obstacle in the goal proximity, because of which the global planner, plans a longer path around. This is the point where the `PathLongerOnApproach` ticks and ticks its children, consequently cancelling the `controller_server` and waiting to see if the obstacle clears up. In the below scenario, the obstacles do not clear, causing the robot to take the longer path.

> 在下面的 GIF 中，可以看到机器人正在接近目标位置，但它**发现了目标附近的障碍物，因此全局规划师制定了一条更长的路线**。这就是`PathLongerOnApproach`触发并触发它的子元素的地方，从而取消`controller_server`并等待障碍物是否清除。在下面的情况下，**障碍物没有清除，导致机器人走更长的路线**。

![image](../../migration/images/nav2_patience_near_goal_and_go_around.gif)

Alternatively, if the obstacles are cleared, then there is a shorter path generated by the global planner. Now, the `PathLongerOnApproach` returns SUCCESS, that cause the `FollowPath` to continue with the robot navigation.

> **如果障碍物被清除，全局规划器会生成一条更短的路径**。现在，`PathLongerOnApproach`返回成功，这导致`FollowPath`继续机器人导航。

![image](../../migration/images/nav2_patience_near_goal_and_clear_obstacle.gif)

Apart from the above scenarios, we also need to note that, the robot will take the longer path to the goal location if the obstacle does not clear up in the given user-specific wait time.

> 除了上述情况之外，我们还需要注意，如果在给定的用户特定的等待时间内障碍物没有清除，机器人将会走更长的路径到达目的地。

In conclusion, this particular BT would serve, both as an example and ready-to-use BT for an organizational specific application, that wishes to optimize its process cycle time.

> 结论而言，这个特定的 BT 将既作为一个例子，也可以作为一个组织特定应用的即用即走 BT，以优化其过程周期时间。

> [!NOTE]
> 引入这个行为树之后，就可以对机器人的行为模式进行进一步的控制，是**对行为层面的控制**

```xml
<root main_tree_to_execute="MainTree">
  <BehaviorTree ID="MainTree">
    <RecoveryNode number_of_retries="6" name="NavigateRecovery">
      <PipelineSequence name="NavigateWithReplanning">
        <RateController hz="1.0">
          <RecoveryNode number_of_retries="1" name="ComputePathToPose">
            <ComputePathToPose goal="{goal}" path="{path}" planner_id="GridBased"/>
            <ClearEntireCostmap name="ClearGlobalCostmap-Context" service_name="global_costmap/clear_entirely_global_costmap"/>
          </RecoveryNode>
        </RateController>
        <ReactiveSequence name="MonitorAndFollowPath">
          <PathLongerOnApproach path="{path}" prox_len="3.0" length_factor="2.0">
            <RetryUntilSuccessful num_attempts="1">
              <SequenceStar name="CancelingControlAndWait">
                <CancelControl name="ControlCancel"/>
                <Wait wait_duration="5"/>
              </SequenceStar>
            </RetryUntilSuccessful>
          </PathLongerOnApproach>
          <RecoveryNode number_of_retries="1" name="FollowPath">
            <FollowPath path="{path}" controller_id="FollowPath"/>
            <ClearEntireCostmap name="ClearLocalCostmap-Context" service_name="local_costmap/clear_entirely_local_costmap"/>
          </RecoveryNode>
        </ReactiveSequence>
      </PipelineSequence>
      <ReactiveFallback name="RecoveryFallback">
        <GoalUpdated/>
        <RoundRobin name="RecoveryActions">
          <Sequence name="ClearingActions">
            <ClearEntireCostmap name="ClearLocalCostmap-Subtree" service_name="local_costmap/clear_entirely_local_costmap"/>
            <ClearEntireCostmap name="ClearGlobalCostmap-Subtree" service_name="global_costmap/clear_entirely_global_costmap"/>
          </Sequence>
          <Spin spin_dist="1.57"/>
          <Wait wait_duration="5"/>
          <BackUp backup_dist="0.30" backup_speed="0.05"/>
        </RoundRobin>
      </ReactiveFallback>
    </RecoveryNode>
  </BehaviorTree>
</root>
```

A complete demo of this BT can be seen in the video below:

```{=html}
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/7AkZiH2Cf_I" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
```
